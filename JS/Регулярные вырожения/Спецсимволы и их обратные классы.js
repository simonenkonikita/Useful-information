✅
/* Спецсимвол точка '.' */

const regex = /iPhone .s/gi; // Поставим точку вместо номера модели 

 В шаблоне регулярного выражения она заменяет любой символ. Неважно, какая цифра стоит перед s, поэтому на её место в шаблоне мы ставим точку.

В шаблоне может быть сколько угодно точек.

const str = `
  Не помню, как именно его зовут:
  то ли Сортини, то ли Сордини.
  Быть может, и Сардини, через «а».
`;

const regex = /С.р.ини/g; // Точки в регулярном выражении заменяют любой символ.

str.match(regex); // [ "Сортини", "Сордини", "Сардини" ]

❗Но у точки есть одна слабость: она не найдёт перенос строки.


✅
/* СПЕЦСИМВОЛЫ - экранирование '\' */

🔶Спецсимволы — такие конструкции из символов в регулярных выражениях, которые позволяют искать не один символ, а сразу группу.

❗многие спецсимволы — это буквы. И чтобы движок понимал, что это не простая буква, а особый символ, в регулярном выражении такой символ нужно экранировать — то есть поставить перед ним обратный слеш \w.

Если экранировать спецсимвол, который должен идти без слеша, движок будет его воспринимать как обычный символ. Например, если поставить обратный слеш перед точкой, движок будет искать только точки, а не любые символы:

const str1 = 'yandex.ru/maps/';
const regex1 = /\.ru/; // экранировали точку
const regex2 = /\/maps/; // экранировали слеш перед словом maps

str1.match(regex1); // [ ".ru" ]
str1.match(regex2); // [ "/maps" ]

// Чтобы найти обратный слеш, его тоже нужно экранировать

const str2 = 'C:\\';
const regex3 = /\\/; // экранировали слеш

str2.match(regex3); // [ "\" ]


✅
/* Спецсимвол \w */

🔶 Этот спецсимвол говорит движку искать любую цифру, латинскую букву или нижнее подчёркивание:

const str = 'Простите, я отправил старую версию файла диплом_финал_2_копия_3.docx. Не смотрите не неё. Высылаю вам актуальную диплом_финал_2_копия_4.docx';

const regex = /диплом\wфинал\w\w\wкопия\w\w.docx/g;

str.match(regex);

// [ "диплом_финал_2_копия_3.docx", "диплом_финал_2_копия_4.docx" ]


✅
/* ОБРАТНЫЙ КЛАСС*/

🔶Итак, обратный класс — это всё равно, что сказать «ищи НЕ такой-то спецсимвол».

➡️
обратный класс: \W. Если \w ищет цифры, латинские буквы и нижние подчёркивания, то \W ищет всё что угодно: знаки вопроса, пробелы, слеши, кириллические символы, — но только не цифры, буквы базовой латиницы и нижние подчёркивания.

const str = `
  Даты основания некоторых IT-компаний:
  Yandex: 23.09.1997
  Apple: 01/04/1976
  IBM: 16-06-1911
`;

const regex = /\w\w\W\w\w\W\w\w\w\w/g;

/* цифры в дате мы обозначили строчной \w, а разделители —
заглавной \W. Разделитель это НЕ цифра, НЕ латинская буква
и НЕ нижнее подчёркивание. */

str.match(regex); // [ "23.09.1997", "01/04/1976", "16-06-1911" ]


✅
/* Спецсимвол \d */

ищет совпадает с любой цифрой:

const str = 'Владивосток 2000';
const regex = /\d\d\d\d/g;

str.match(regex); // [ "2000" ]

➡️
Обратный класс этого символа совпадает со всеми не-цифрами: буквами, пробелами, спецсимволами.

// найдёт все символы, кроме цифр

const someSimbol = /\D/g;
const string = 'I was born in 1987';

string.match(someSimbol);

// ["I", " ", "w", "a", "s", " ", "b", "o", "r", "n", " ", "i", "n", " "]


✅
/* Спецсимвол \s */

ищет «пустоты» в тексте: пробелы, в том числе неразрывные, переносы строк и табуляции. 

const str = 'Сдают паспорта,\n' +
                    '              и я' +
                    '                сдаю';

const regex = /\s/g;

str.match(regex).length; // 32 — Маяковский любил пробелы

➡️
обратный класс \S ищет любые символы, только не пробелы, табуляции и переносы:

const str = 'Сдают паспорта,\n' +
                    '              и я' +
                    '                сдаю';

const regex = /\S/g;

str.match(regex).length; // 22

// букв с запятыми получилось на десяток меньше


✅
/* Спецсимвол \b */

означает границу слова. Движок считает границей слова:

-начало строки;
-конец строки;
-любой символ, кроме цифр, латинских букв и нижнего подчёркивания.

const string = 'sadness';

string.match(/\bs/).index; // 0 — это первая буква s
// спецсимвол указал границу левее неё, т. е. начало

string.match(/s\b/).index; // 6 - а это последняя
// спецсимвол указал границу правее неё, т. е. конец

❗Обратите внимание: любая нелатинская буква прочитывается движком как отдельное слово. Поэтому с кириллицей спецсимвол \b не работает.

✅
обратный класс \B — он ищет не конец слова: цифру, латинскую букву или нижнее подчёркивание. Таким образом, \B делает то же самое, что \w.


✅
/* Начало и конец строки '^' и '$' */

➡️ ^ - Спецсимвол, обозначающий начало строки. Говорит шаблону, что нужно искать совпадение только с началом текста:

const regex = /^\d+/g;
const newReg = /\d+/g;
const    str = '2001 год: Космическая одиссея, вышел в 1968 году';

str.match(regex); // [ "2001" ];
str.match(newReg); // [ "2001", "1968" ];

➡️ $ -Символ конца строки. угодноказывает искать совпадение с концом текста:

const regex = /\d+$/;
const    str = 'https://praktikum.yandex.ru/trainer/frontend-developer/lesson/45';

str.match(regex); // ( ["45"] )


✅
/* Многострочные тексты \n */

Чтобы написать многострочный текст, перенос можно поставить комбинацией символов \n или пользоваться обычными переносами в шаблонных строках:

const str1 = `Председатель Совнаркома, Наркомпроса, Мининдела!
Эта местность мне знакома, как окраина Китая!`;
const str2 = 'Это утро, радость эта,\nЭта мощь и дня и света,'

❗движк считает началом строки только то, что стоит после открывающей кавычки, а концом — до закрывающей:

const str = `Председатель Совнаркома, Наркомпроса, Мининдела!
Эта местность мне знакома, как окраина Китая!`;
const regex = /[А-Я]*!$/gi; // найдём последние слова каждой строки

str.match(regex); // ["Китая!"] — получилось только последнее слово всего текста


✅
/* Многострочные тексты \m */

❗Чтобы изменить такое поведение движка, нужно установить флаг m. Тогда движок будет считать каждый перенос концом одной строки и началом другой:

const str = `Эта личность мне знакома! Знак допроса вместо тела.
Многоточие шинели. Вместо мозга — запятая.`;
const regex = /[А-Я]*\.$/gim;

str.match(regex); // [ "тела.", "запятая." ]

❗Это работает и с шаблонными строками, и с обычными: в них движок будет считать началом и концом строки комбинации \n!


✅
/* Трудности с точкой */

❗если нужно искать совпадение с абсолютно любым символом, пользуйтесь набором [\s\S]:

❗начало строки обозначают шляпкой ^, а конец — знаком доллара $. По умолчанию весь текст — одна строка, у которой есть один конец и одно начало.
Такое поведение движка можно изменить, поставив флаг m. Флаг m говорит движку, чтобы тот воспринимал каждый перенос как конец одной строки и начало другой.

const regex = /.*$/;
const regexMultiline = /.*$/m;
const    str = 'I got, I got, I got, I got\n' +
                    'Loyalty, got royalty\n' +
                    'Inside my DNA\n' +
                    'Coconut quarter piece, got war and peace\n' +
                    'Inside my DNA\n' + 
                    'I got power, poison, pain and joy\n' +
                    'Inside my DNA\n' +
                    'I got hustle, though, ambition, flow\n' +
                    'Inside my DNA'

str.match(regexMultiline); // [ "I got, I got, I got, I got" ]

/* Флаг m включён, поэтому движок отсчитал
сколько мог любых символов от конца первой строки */

str.match(regex); // [ "Inside my DNA" ]

/* Тут флаг m выключен, поэтому движок отсчитывает
символы от конца строки. Точка в шаблоне означает
любой символ, кроме переноса. Поэтому мы нашли
только последнюю строчку */



1️⃣ 2️⃣ 3️⃣ 4️⃣ 5️⃣ 6️⃣ 7️⃣ 8️⃣ 9️⃣ 🔟 🔢 0️⃣ #️⃣ 🔣 ◀️ ⬇️ ▶️ ⬅️ 🔠 🔡 🔤 ↙️ ↘️ ➡️➡️ ⬆️ ↖️ ↗️ ⏬ ⏫ 🔽 ⤵️ ⤴️ ↩️ ↪️ ↔️ ↕️ 🔼 🔃 🔄 ⏪ ⏩ ℹ️ 🆗 🔀 🔁 🔂 🆕 🔝 🆙 🆒 🆓 🆖 🎦 🈁 📶 🈹 🈴 🈺 🈯 🈷️ 🈶 🈵 🈚 🈸 🈳 🈲 🈂️ 🚻 🚹 🚺 🚼 🚭 🅿️ ♿ 🚇 🛄 🉑 🚾 🚰 🚮 ㊙️ ㊗️ Ⓜ️ 🛂 🛅 🛃 🉐 🆑 🆘 🆔 🚫 🔞 📵 🚯 🚱 🚳 🚷 🚸 ⛔ ✳️ ❇️ ✴️ 💟 🆚 📳 📴 💹 💱 ♈ ♉ ♊ ♋ ♌ ♍ ♎ ♏ ♐ ♑ ♒ ♓ ⛎ 🔯 ❎ 🅰️ 🅱️ 🆎 🅾️ 💠 ♻️ 🔚 🔙 🔛 🔜 🕐 🕜 🕙 🕥 🕚 🕦 🕛 🕧 🕑 🕝 🕒 🕞 🕓 🕟 🕔 🕠 🕕 🕡 🕖 🕢 🕗 🕣 🕘 🕤 💲 ©️ ®️ ™️ ❌ ❗❗ ‼️ ⁉️ ⭕ ✖️ ➕ ➖ ➗ 💮 💯 ✔️ ☑️ 🔘 🔗 ➰ 〰️ 〽️ 🔱 ▪️ ▫️ ◾ ◽ ◼️ ◻️ ⬛ ⬜ ✅
 🔲 🔳 ⚫ ⚪ 🔴 🔵 🔷 🔶 🔹 🔸 🔺 🔻
✏️ Пример написания: