✅
/* Promise ==================================================*/

🔶Промис — часть отдельного API, специально сделанного для работы с асинхронным кодом. 

✏️ Пример написания:

// fetch — это функция для запроса на сервер,
fetch('https://socialnetwork.com/users')
  .then(getIvan)
  .then(getAnna)
    .then(getMutualFriends)
    .then((mutualFriends) => {
    alert(`У Анны и Ивана ${mutualFriends} общих друзей`)
  });


✅
/* Концепция промисов ========================================*/

❗Код функции, переданной функции Promise, исполняется немедленно

❗Нужно прописать логику: что делать движку, если промис будет обработан, и что — если отклонён. Для этого у промисов есть три метода:

➡️then — выполнится, если промис исполнен;
➡️catch — если отклонён;
➡️finally — выполнится в любом случае независимо от статуса промиса.

Первые два метода, then и catch, принимают на вход функцию с одним параметром.Этот параметр — то самое значение, с которым мы вызывали resolve и reject при создании промиса. В нашем случае это одна из двух строк — 'Запрос обработан успешно' или 'Запрос отклонён':

Первая функция — resolve. Она переводит промис в статус «исполнен», а значение, переданное этой функции, затем передаётся методу then.

Вторая функция — reject. Она переводит промис в статус «отклонён». Переданное этой функции значение затем передаётся на вход методу catch.

Поэтому, чтобы создать промис, нужно сначала вызвать функцию Promise, а затем описать в методах then и catch, что мы хотим делать в случае успеха, а что — в случае неудачи.


// Создаём промис
const newPromise = new Promise(function (resolve, reject) {
  /* Будем определять, обработан запрос
  или нет, случайным образом */
    const rand = Math.random() > 0.5 ? true : false;

    if (rand) {
        resolve('Запрос обработан успешно');
    } else {
        reject('Запрос отклонён');
    }
});

newPromise
  .then(function (value) { // Если промис был обработан

    /* Параметр value хранит значение, переданное методу
    resolve при создании промиса, то есть строку
    "Запрос обработан успешно" */

      console.log(value);
  })
  .catch(function (value) { // Если промис был отклонён

    /* Здесь параметр value будет хранить то значение,
    которое было передано методу reject, то есть строку
    "Запрос отклонён" */

      console.log(value + ', нам жаль :(');
  })
  .finally(function () { // В любом случае
      console.log('Как бы там ни было — запрос мы в глаза видели');
}); 

 
✅
/* Цепочка обработки запроса =================================*/

🔶Промисы позволяют добавлять задачи в асинхронную очередь. Для этого нужно дописать в коде ещё один then или catch. Первые then и catch на странице получат те значения, которые мы передавали на вход функциям resolve и reject. Все последующие — то, что возвращали предыдущие методы then и catch.

const newPromise = new Promise(function (resolve, reject) {
  resolve('Раз'); // Сразу получим обработанный промис
});

function firstAction(value) {
/* Значением value станет то, что мы передали
функции resolve при создании промиса.
То есть строка "Раз". */

  return `${value}, два`;
}

function secondAction(value) {
/* Тут значение value — это то, что вернёт
предыдущий метод then, то есть строка "Раз, два" */

  return `${value}, три`;
}

function thirdAction(value) {
  console.log(value);
}

newPromise
  .then(firstAction)
  .then(secondAction)
  .then(thirdAction);

/* В консоли окажется: "Раз, два, три" */

🔶Аналогично для отклонённых промисов:

const newPromise = new Promise(function (resolve, reject) {
  reject('Раз'); // Сразу получим отклонённый промис
});

function firstAction(value) {
  return `${value}, два`;
}

function secondAction(value) {
  return `${value}, три`;
}

function thirdAction(value) {
  console.log(value);
}

newPromise
.then(firstAction)
.then(secondAction)
.catch(thirdAction);

/* В консоли окажется: "Раз", так как newPromise
был отклонён и мы сразу попали в блок catch */

❗Код функции, которую мы передаём методам catch и then, тоже может приводить к ошибке.
Всегда завершайте цепочки промисов блоком catch. Это позволит обработать ошибку, если она возникнет в любом then из цепочки.


✅
/*Статические методы /Методы Promise.resolve и Promise.reject */

Если вы сразу хотите создать исполненный или отклонённый промис, вызывать new Promise необязательно. Можно обратиться к методам Promise.resolve и Promise.reject. Эти методы создают промис, переводят его в статус «исполнен» или «отклонён» соответственно, и записывают как результат промиса — то, что мы передали этим методам.

Promise.resolve('Этот промис исполнен')
  .then(function (value) {
    console.log(value); // "Этот промис исполнен"
  });

Promise.reject('Этот промис отклонён')
  .catch(function (value) {
    console.log(value); // "Этот промис отклонён"
});


✅
/* Метод Promise.all =========================================*/

У вас на странице может быть несколько промисов. Например, вы запрашиваете картинку с одного сервера, а текст — с другого. И из них нужно собрать пост. Очевидно, нет смысла выкладывать ни картинку без текста, ни текст без картинки. Иными словами — создавать пост мы будем только после того, как оба промиса будут в статусе «исполнен».
Для этого есть статический метод Promise.all. Он принимает на вход массив с промисами и выполняет записанный в then код, только когда все промисы вернулись со статусом «исполнен»:

// Создаём первый промис
const firstPromise = new Promise((resolve, reject) => {
  if (someCondition) {
    resolve('Первый промис');
  } else {
    reject();
  }
});

// Создаём второй промис
const secondPromise = new Promise((resolve, reject) => {
  if (secondCondition) {
    resolve('Второй промис');
  } else {
    reject();
  }
});

// Создаём массив с промисами
const promises = [firstPromise, secondPromise]

// Передаём массив с промисами методу Promise.all
Promise.all(promises)
  .then((results) => {
    console.log(results); // ["Первый промис", "Второй промис"]
});


























1️⃣ 2️⃣ 3️⃣ 4️⃣ 5️⃣ 6️⃣ 7️⃣ 8️⃣ 9️⃣ 🔟 🔢 0️⃣ #️⃣ 🔣 ◀️ ⬇️ ▶️ ⬅️ 🔠 🔡 🔤 ↙️ ↘️ ➡️➡️ ⬆️ ↖️ ↗️ ⏬ ⏫ 🔽 ⤵️ ⤴️ ↩️ ↪️ ↔️ ↕️ 🔼 🔃 🔄 ⏪ ⏩ ℹ️ 🆗 🔀 🔁 🔂 🆕 🔝 🆙 🆒 🆓 🆖 🎦 🈁 📶 🈹 🈴 🈺 🈯 🈷️ 🈶 🈵 🈚 🈸 🈳 🈲 🈂️ 🚻 🚹 🚺 🚼 🚭 🅿️ ♿ 🚇 🛄 🉑 🚾 🚰 🚮 ㊙️ ㊗️ Ⓜ️ 🛂 🛅 🛃 🉐 🆑 🆘 🆔 🚫 🔞 📵 🚯 🚱 🚳 🚷 🚸 ⛔ ✳️ ❇️ ✴️ 💟 🆚 📳 📴 💹 💱 ♈ ♉ ♊ ♋ ♌ ♍ ♎ ♏ ♐ ♑ ♒ ♓ ⛎ 🔯 ❎ 🅰️ 🅱️ 🆎 🅾️ 💠 ♻️ 🔚 🔙 🔛 🔜 🕐 🕜 🕙 🕥 🕚 🕦 🕛 🕧 🕑 🕝 🕒 🕞 🕓 🕟 🕔 🕠 🕕 🕡 🕖 🕢 🕗 🕣 🕘 🕤 💲 ©️ ®️ ™️ ❌ ❗❗ ‼️ ⁉️ ⭕ ✖️ ➕ ➖ ➗ 💮 💯 ✔️ ☑️ 🔘 🔗 ➰ 〰️ 〽️ 🔱 ▪️ ▫️ ◾ ◽ ◼️ ◻️ ⬛ ⬜ ✅ 🔲 
🔳 ⚫ ⚪ 🔴 🔵 🔷 🔶 🔹 🔸 🔺 🔻
✏️ Пример написания: