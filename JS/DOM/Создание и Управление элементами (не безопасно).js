❗❗❗❗❗❗❗❗❗innerHTML и insertAdjacentHTML —использовать их аккуратно, особенно когда встраиваете в разметку текст, который вводит пользователь.❗❗❗❗❗❗❗❗❗

✅
/* Гибкая вставка: методы insertAdjacentHTML и insertAdjacentText*/

✅✅✅insertAdjacentHTML и insertAdjacentText НЕ ПЕРЕСОЗДАЮТ БЛОКИ DOM- ДЕРЕВА ЗАНОВО ✅✅✅

🔶 Чтобы не терять данные в элементах, существуют методы insertAdjacentHTML и insertAdjacentText. Они добавляют разметку и текст в документ и не затрагивают существующие элементы.

✏️ Пример написания:

zoo.insertAdjacentHTML('beforeend', '<div class="tiger"></div>');

'beforeend' -перед закрывающим тегом элемента.
'beforebegin' — вставка до открывающего тега;
'afterbegin' — вставка после открывающего тега;
'afterend' — вставка после закрывающего тега.

Относительно разметки блока это выглядит так:

<!-- beforebegin -->
<div>
    <!-- afterbegin -->
    
    <!-- существующая разметка-->
    
    <!-- beforeend -->
</div>
<!-- afterend -->

❗❗❗Свойство insertAdjacentText работает аналогичным образом, только вставляет текст, как и свойство textContent.


✅
/* Содержимое элемента. Свойство innerHTML*/

🔶 Свойство innerHTML содержит в себе строку со всем наполнением элемента (в том числе и разметкой):

✏️ Пример написания:

document.body.innerHTML; // Если в документе нет разметки, вернёт пустую строку.

innerHTML позволяет не только получить значение свойства, но и перезаписать его:

document.body.innerHTML = '<div>Добавим разметку</div>'; // Теперь на странице есть только один div. Если бы перед этим в документе была какая-либо разметка, она была бы заменена этим одним div.

Свойством innerHTML можно прочитать, изменить или удалить содержимое элемента:

document.body.innerHTML = ''; // записав пустую строку, можно удалить всё содержимое элемента.

console.log();
✅
/* Текстовое содержимое. Свойство textContent*/

🔶textContent позволяет получить или перезаписать текстовое содержимое элемента. Обратите внимание: вёрстка при этом не затрагивается.

✏️ Пример написания:

<p id="paragraph">Это текст внутри элемента.</p>

let paragraph = document.getElementById('paragraph');
console.log(paragraph.textContent); // "Это текст внутри элемента."
paragraph.textContent = 'А это новый текст.'; // можно перезаписать содержимое

❗Перезапись свойства textContent изменит текстовое содержимое элемента

❗Если в один элемент вложены другие, их текстовое содержимое склеится:

✏️ Пример написания:

<p id="paragraph">
  Это текст внутри элемента.
  <span>А это текст вложенного элемента.</span>
</p>

let paragraph = document.getElementById('paragraph');
console.log(paragraph.textContent);

/*
  Это текст внутри элемента.
  А это текст вложенного элемента.
*/

❗ не рекомендуем обращаться к свойству textContent тех элементов, в которые вложены другие. textContent учтёт все пробелы в HTML-разметке как текстовое содержимое — в том числе и отступы перед тегами. Прибегайте к свойству textContent точечно для текстовых элементов.


✅
/* Другой способ заменить текстовое содержимое. Свойство innerText*/

🔶Есть ещё одно свойство — innerText, которое тоже предназначено для получения текстового содержимого. Оно отличается от textContent тем, что innerText возвращает только видимое текстовое содержимое. То есть innerText проигнорирует всё, что скрыто свойством display: none, а textContent — нет:

✏️ Пример написания:

<p id="paragraph">
  Это текст внутри элемента.
  <span style="display: none;">Невидимый текст.</span>
</p>

let paragraph = document.getElementById('paragraph');

console.log(paragraph.innerText); // Это текст внутри элемента.
console.log(paragraph.textContent);
/* Это текст внутри элемента.
Невидимый текст. */

❗❗❗
Когда нужно прочитать или изменить текстовое содержимое, лучше обращаться к textContent. На это есть две причины:
❗textContent работает гораздо быстрее, потому что игнорирует правила видимости.
❗Свойство innerText не стандартизировано. Его придумали в Microsoft ещё до появления textContent. Оно стало популярным, и другие производители начали внедрять его в свои браузеры. Но в стандарте innerText по-прежнему нет, а значит, его поведение в разных браузерах может отличаться. А ещё нет гарантий, что оно не изменится в будущем.
❗Запомнить стоит два свойства: innerHTML и textContent. Первое пригодится для управления разметкой, второе — текстовым содержимым.
❗❗❗

✅✅✅ВСЕ ЭТИ СВОЙСТВА ПЕРЕСОЗДАЮТ БЛОКИ DOM- ДЕРЕВА ЗАНОВО ✅✅✅



Symbols
1️⃣ 2️⃣ 3️⃣ 4️⃣ 5️⃣ 6️⃣ 7️⃣ 8️⃣ 9️⃣ 🔟 🔢 0️⃣ #️⃣ 🔣 ◀️ ⬇️ ▶️ ⬅️ 🔠 🔡 🔤 ↙️ ↘️ ➡️➡️ ⬆️ ↖️ ↗️ ⏬ ⏫ 🔽 ⤵️ ⤴️ ↩️ ↪️ ↔️ ↕️ 🔼 🔃 🔄 ⏪ ⏩ ℹ️ 🆗 🔀 🔁 🔂 🆕 🔝 🆙 🆒 🆓 🆖 🎦 🈁 📶 🈹 🈴 🈺 🈯 🈷️ 🈶 🈵 🈚 🈸 🈳 🈲 🈂️ 🚻 🚹 🚺 🚼 🚭 🅿️ ♿ 🚇 🛄 🉑 🚾 🚰 🚮 ㊙️ ㊗️ Ⓜ️ 🛂 🛅 🛃 🉐 🆑 🆘 🆔 🚫 🔞 📵 🚯 🚱 🚳 🚷 🚸 ⛔ ✳️ ❇️ ✴️ 💟 🆚 📳 📴 💹 💱 ♈ ♉ ♊ ♋ ♌ ♍ ♎ ♏ ♐ ♑ ♒ ♓ ⛎ 🔯 ❎ 🅰️ 🅱️ 🆎 🅾️ 💠 ♻️ 🔚 🔙 🔛 🔜 🕐 🕜 🕙 🕥 🕚 🕦 🕛 🕧 🕑 🕝 🕒 🕞 🕓 🕟 🕔 🕠 🕕 🕡 🕖 🕢 🕗 🕣 🕘 🕤 💲 ©️ ®️ ™️ ❌ ❗❗ ‼️ ⁉️ ⭕ ✖️ ➕ ➖ ➗ 💮 💯 ✔️ ☑️ 🔘 🔗 ➰ 〰️ 〽️ 🔱 ▪️ ▫️ ◾ ◽ ◼️ ◻️ ⬛ ⬜ ✅ 🔲 🔳 ⚫ ⚪ 🔴 🔵 🔷 🔶 🔹 🔸 🔺 🔻
✏️ Пример написания:
