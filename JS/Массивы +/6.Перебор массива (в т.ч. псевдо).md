## Перебор массива. Методы forEach и map

Метод forEach нужен, когда мы хотим просто пройтись по массиву и для каждого элемента что-то сделать.
Метод map нужен, когда мы хотим создать новый массив из старого и преобразовать его элементы.
Колбэк методов forEach и map имеют три аргумента:

```
Текущий элемент, его индекс и исходный массив
```

### Обход массива / Метод forEach

Метод forEach нужен для обхода массива.

В качестве аргумента forEach принимает функцию. Она будет вызвана на каждом элементе массива поочерёдно:

```javascript
const how = ["быстрее", "выше", "сильнее"];

how.forEach(function (item) {
  console.log(item + ".");
});

/*
  быстрее.
  выше.
  сильнее.
*/
```

Методу forEach мы передали функцию. forEach вызовет её столько раз, сколько элементов в массиве how. При каждом вызове forEach передаёт функции текущий элемент массива в качестве аргумента. Поэтому в передаваемой нами функции item — это текущий элемент массива. Параметр item можно назвать и по-другому. Но лучше сделать так, чтобы название отражало содержание.

Метод forEach удобно использовать для работы с массивоподобными объектами. Например, с NodeList. Частая задача — пройтись по нескольким DOM элементам, вызвав для каждого из них функцию:

```javascript
const elements = document.querySelectorAll(".text");

elements.forEach((item) => {
  item.classList.add("text_is-active");
});
```

Метод forEach — более удобная для работы с массивом версия цикла for:

```javascript
const how = ["быстрее", "выше", "сильнее"];

for (let i = 0; i < how.length; i += 1) {
  console.log(how[i] + ".");
}
```

Этот цикл работает аналогично методу:

```javascript
const how = ["быстрее", "выше", "сильнее"];

how.forEach(function (item) {
  console.log(item + ".");
});

/*
  быстрее.
  выше.
  сильнее.
*/
```

❗Но с forEach нельзя использовать директивы continue и break. Поэтому метод не используют, когда нужно прервать выполнение цикла каким-то условием.

### Создание одного массива из другого / Mетод map

Метод map создаёт новый массив на основе существующего. В качестве аргумента map, как и forEach, принимает функцию. Эта функция должна вернуть значение, которое станет элементом нового массива.

```javascript
const firstArr = [0, 1, 2, 3, 4];

const secondArr = firstArr.map(function (item) {
  // Берём каждый элемент массива
  return item * item; // Возводим каждый элемент в квадрат
});

console.log(secondArr); // [0, 1, 4, 9, 16]
```

❗Результат работы функции — то, что указано после ключевого слова return. Если не прописать return, функция сработает, но вернёт undefined.

❗Метод map нельзя применить к массивоподобным объектам. Если попытаться вызвать код с NodeList из примера с forEach — вылезет ошибка: / TypeError: elements.map is not a function // потому что у elements нет метода map

Сначала нужно превратить массивоподобный объект в полноценный массив используется метод - Array.from

Метод map удобно использовать в тех случаях, когда нужно сохранить исходный массив:

```javascript
const elements = document.querySelectorAll(".text");
const elementsArr = Array.from(elements);

const newArr = elementsArr.map((item) => {
  item.classList.add("text_is-active");
});
```

## Аргументы методов forEach и map

- Аргумент 1. Текущий элемент массива

Текущий элемент массива используется часто, поэтому и стоит на первом месте. Если другие аргументы не нужны, достаточно прописать его:

```javascript
const positions = [
  "Великий Умывальник",
  "Знаменитый Мойдодыр",
  "Умывальников Начальник",
  "Мочалок Командир",
];

// Переданный колбэк будет вызван 4 раза. По очереди с каждым элементом массива positions

positions.forEach(function (item) {
  console.log(item);
});

Великий Умывальник
Знаменитый Мойдодыр
Умывальников Начальник
Мочалок Командир
```

- Аргумент 2. Индекс текущего элемента

Когда мы говорили о цикле for, там был счётчик цикла. Второй аргумент колбэка — фактически такой счётчик. Его можно использовать, например, для расстановки позиций в списке:

```javascript
const counter = [
  "Царь",
  "Царевич",
  "Король",
  "Королевич",
  "Сапожник",
  "Портной",
];

const counterIndexed = counter.map(function (person, index) {
  return `${index + 1}. ${person}`;
});

console.log(counterIndexed);

[
  "1. Царь",
  "2. Царевич",
  "3. Король",
  "4. Королевич",
  "5. Сапожник",
  "6. Портной",
];
```

❗Неважно, какое имя параметра выбрано в объявлении функции — person, item или любое другое. Первый параметр считывается как текущий элемент, второй — как его индекс.

- Аргумент 3. Исходный массив

Исходный массив как аргумент пригодится, когда нужно обратиться к свойствам этого исходного массива:

```javascript
const ivans = [
  "Иван I Калита",
  "Иван II Красный",
  "Иван III Великий",
  "Иван IV Грозный",
  "Иван V",
  "Иван VI",
];

const ivansIndexed = ivans.map(function (item, index, array) {
  const currentIndex = `(${index + 1} из ${array.length})`;
  return `${item} ${currentIndex}`;
});

console.log(ivansIndexed);

[
  "Иван I Калита (1 из 6)",
  "Иван II Красный (2 из 6)",
  "Иван III Великий (3 из 6)",
  "Иван IV Грозный (4 из 6)",
  "Иван V (5 из 6)",
  "Иван VI (6 из 6)",
];
```


## Пербор масcива циклом for без метода forEach

```javascript
const tweets = [
  "Какой-то странный тред",
  "Твит, адресованный Илону Маску",
  "Ответ на инфоповод",
];
```

```javascript
function forEach(arr, callback) {
  for (
    let i = 0;
    i < arr.length;
    i += 1 // означает, что цикл будет выполняться, пока значение i меньше длины массива (свойство length)
  )
    callback(arr[i]); // на каждой итерации передаем текущее значение массива в колбэк: callback(arr[i]).
}
```

```javascript
forEach(tweets, function (tweet) {
  console.log(tweet);
});
```
