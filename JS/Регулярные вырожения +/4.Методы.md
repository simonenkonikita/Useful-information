## Методы работы с регулярными выражениями

Все методы для работы с регулярными выражениями ищут текст в строке, а различаются только назначением.

Регулярные выражениями бывают двух типов:

## Виды методов

### Методы строк

match — строковый метод. Поэтому мы вызываем его как метод строки, а регулярное выражение передаём как аргумент

```javascript
const regex = /л/;
const word = "солнце";

word.match(regex); // [ "л" ] — метод нашёл символ в строке
```

### Методы регулярных выражений

test — метод объекта RegExp. Поэтому мы вызываем его как метод переменной regExp и передаём строку как аргумент.

```javascript
const regex = /т/;
const word = "лестница";

regex.test(word); // true — метод подтвердил, что в строке есть совпадение
```

## Методы

### Метод String.match

Нужен для поиска совпадений: им вы можете проверить, есть ли слово в тексте, и посчитать, сколько раз оно встречается.

- Метод String.match принимает один аргумент — регулярное выражение.

- Если символ найти не удалось, String.match вернёт null.

- Если найти строку удалось, String.match вернёт массив с тем, что нашёл:

```javascript
const regex = /сс/;
const word = "рассчитывать";

word.match(regex); // [ "сс" ]
```

Если передать методу String.match регулярное выражение без флага g, полученному массиву будут определены дополнительные свойства:

```javascript
const str = "тро-ло-ло";
const result = str.match(/ло/);

result[0]; // "ло"
result.index; // 4
result.input; // "тро-ло-ло"
```

Если искать по регулярному выражению с флагом g, дополнительных свойств в итоговом массиве не будет. Мы получим просто массив, состоящий из строк:

```javascript
const str = "тро-ло-ло";
const result = str.match(/ло/g);

result; // ["ло", "ло"]
```

### Метод String.split

Методу String.split можно передать на вход и регулярное выражение. Тогда на выходе мы получим массив элементов, которые находили между строчками, найденными нашей регуляркой:

```javascript
const regex = /\n/im;

`Мой дядя самых честных правил,
Когда не в шутку занемог,
Он уважать себя заставил
И лучше выдумать не мог.`.split(regex);
```

```javascript
[
  "Мой дядя самых честных правил,",
  "Когда не в шутку занемог,",
  "Он уважать себя заставил",
  "И лучше выдумать не мог.",
];
```

Обратите внимание: метод String.split ожидает, что какой-то элемент должен быть и до, и после разделителя. Поэтому если ваша строка начинается с разделителя или заканчивается разделителем, в полученном массиве первым или последним элементом будет пустая строка.

### Метод RegExp.test

Он вызывается на регулярном выражении, а строку принимает на вход. Результат работы метода — булевое значение. \
Если совпадение найти удалось, RegExp.test вернёт true, Если же совпадений с регулярным выражением в строке нет, получим false:

```javascript
const regex = /\w+@\w+\.\w+/; // шаблон для поиска email
const str = "Stas Basov: stasbasov@yandex.ru";

regex.test(str); // true
```

- Если установить флаг g, метод RegExp.test будет вести себя несколько иначе. Он вернёт первое совпадение, а затем — запишет в свойство lastIndex регулярного выражения номер символа в тексте, на котором это совпадение произошло.

- Если запустить метод RegExp.test снова, он будет искать не с начала строки, а с того символа, на котором остановился в прошлый раз. То есть с записанного в свойство lastIndex:

- RegExp.test обновляет свойство lastIndex после каждого вызова.

- Таким образом, метод RegExp.test помнит, где закончил поиски в прошлый раз. Если запустить этот метод в цикле, мы можем точно контролировать, сколько совпадений хотим найти.

- Если очередной поиск не дал результатов, в свойство lastIndex регулярного выражения записывается 0. То есть новый поиск начнётся с начала.

### Метод String.replace

Позволяет на ходу собирать новый текст из исходного. Работает он так: ищет в тексте совпадение с регуляркой, составляет какую-то новую строку из полученной и возвращает её нам.

Всего у метода два параметра.

- Первый — шаблон регулярного выражения.
- Вторым аргументом может быть строка или функция. Именно второй параметр определяет, как именно будет составлена новая строка из совпадения.

Чаще всего методу String.replace передают строку. Все совпадения в исходном тексте будут заменены этой строкой.

```javascript
const strObj = "Пробел всегда нужно ставить после запятой ,а не до неё.";
const regex = /\s,/g;

strObj.replace(regex, ", "); // "Пробел всегда нужно ставить после запятой, а не до неё."
```

В этой строке можно использовать спецсимволы. Тогда движок не будет просто заменять совпадения какой-то строкой. Спецсимволы применяются редко, поэтому мы не будем их разбирать в этой теме.

